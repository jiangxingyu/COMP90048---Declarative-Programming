-- Author: Jiangxing Yu <jiangxingy@student.unimelb.edu.au>
-- Purpose: The Game of Musician

-- This Game is about guess the Musician Pitch set, there are two player.
-- The first player will guess the musician pitch set, and there is another 
-- player couldgive feedback of the guess. The the first program will give 
-- next guess by analysing the feedback. One pitch set includes three pitches,
-- and every pitch is composed by a note from A,B,C,D,E,F,G and a octave from 
-- 1,2,3. The three pitches are different in one set.
-- The feedback is composed by three numbers:
-- 1. how many pitches in the guess are included in the target (right pitches)
-- 2. how many pitches have the right note but the wrong octave (right notes)
-- 3. how many pitches have the right octave but the wrong note(right octaves)


module Proj1 (Pitch, toPitch, feedback, 
            GameState, initialGuess, nextGuess) where

import Data.List
import Data.Char

-- Define data Pitch, which include two char: note and octave
data Pitch = Pitch Char Char
    deriving (Eq)

-- Rewrite show of Pitch
instance Show Pitch where
    show (Pitch note octave) = [note, octave]

-- Transfer a String to a Pitch data structure
toPitch :: String -> Maybe Pitch
toPitch (note:octave:str)
    | str /= [] = Nothing
    | note >= 'A' && note <= 'G' && 
        octave >= '1' && octave <= '3' = Just (Pitch note octave)
    | otherwise = Nothing
toPitch _ = Nothing

-- Transfet a Pitch data structure to a String
toString :: Pitch -> String
toString (Pitch note octave) = [note, octave]

-- Gets the note information of a Pitch
getNote :: Pitch -> Char
getNote (Pitch note octave) = note

-- Gets the octave information of a Pitch
getOctave :: Pitch -> Char
getOctave (Pitch note octave) = octave

-- Analyse target and guess pitch set, and return the feedback,
-- which includes three numbers: the number of right pitches,
-- the number of right notes and the number of right octaves.
feedback :: [Pitch] -> [Pitch] -> (Int, Int, Int)
feedback target guess = (lengthRight, lengthNotes, lengthOctave)
    where 
        targetNotes = map getNote target
        targetOctaves = map getOctave target
        guessNotes = map getNote guess
        guessOctaves = map getOctave guess
        pitchRight = target \\ guess
        octavesRight = targetOctaves \\ guessOctaves
        notesRight = targetNotes \\ guessNotes
        lengthRight = 3 - length (pitchRight)
        lengthNotes = 3 - length (notesRight) - lengthRight
        lengthOctave = 3 - length (octavesRight) - lengthRight

-- Define GameState, which is the candidates group of target.
-- It is defined as a list of pitch sets
type GameState = [[Pitch]]

-- Generate all kinds of Pitchs which are the combinations of notes and octaves
initPitches :: [Pitch]
initPitches = [Pitch n o | n <- notes, o <- octaves]
    where
        notes = "ABCDEFG"
        octaves = "123"

-- Init the GameState: generate a group of all kinds of pitch sets, which are the 
-- initial candidates of target pitch set. we will find the target in this group.
initGameState :: [Pitch] -> [[Pitch]]
initGameState pitchs = [[pitch1, pitch2, pitch3] | 
    pitch1 <- pitchs, pitch2 <- pitchs, pitch3 <- pitchs,
    toString(pitch1) > toString(pitch2) 
    && toString(pitch2) > toString(pitch3)]

-- Generate the initial pitch set to guess and the initial GameState.
initialGuess :: ([Pitch], GameState)
initialGuess = (pitchGuess, initGameState pitchs)
    where   
        pitchs = initPitches
        pitchGuess = [Pitch 'A' '1', Pitch 'B' '2', Pitch 'C' '3']

-- Generate new guess and GameState according to the last guess, 
-- GameState and feedback. The algorithm steps are as follows:
-- 1. call removeCandidate to narrow the candidates of target 
--    and update GameState.
-- 2. call selectBestCandidate to choose the next guess 
nextGuess :: ([Pitch], GameState) -> (Int,Int,Int) -> ([Pitch], GameState)
nextGuess (pitchSet, candidates) fd = 
    (selectBestCandidate surviveCandidate, surviveCandidate)
    where
        surviveCandidate = removeCandidate pitchSet candidates fd


-- This function narrow the candidates of the target according to the guess and the feedback
-- The algorithm steps are as follows:
-- 1. calculate all the feedback between the guess and candidates.
-- 2. choose the candidates whose feedback same as the feedback between 
-- guess and target, then the target must be in the candidates.
removeCandidate :: [Pitch] -> [[Pitch]] -> (Int, Int, Int) -> [[Pitch]]
removeCandidate pitchSet pitchSetCandidates fd = 
    filter (\p -> (feedback pitchSet p) == fd) pitchSetCandidates

-- Analyze the expectations of the number of candidates that will be 
-- generated by everyone in current candidates group, and then select 
-- the pitch set which have the smallest expectation to be the next guess.
-- The reason is that we should narrow the candidates down as much as possible
selectBestCandidate :: [[Pitch]] -> [Pitch]
selectBestCandidate pitchcandidates = minExpectionPitchSet
    where
        sortablePitchSets = [(calculateExpectation pitchSet pitchcandidates, 
            map toString pitchSet) | pitchSet <- pitchcandidates]
        minSortablePitchSet = minimum sortablePitchSets
        minExpectionPitchSet = map stringToPitch (snd minSortablePitchSet)
        stringToPitch str = Pitch (str!!0) (str!!1)

-- Calculate the expectation of the number of candidates that will be generated 
-- of a pitch set when the pitch set become the next guess.
-- The algorithm steps are as follows:
-- 1. calculate feedbacks of the Pitch set with all other candidates, then we
-- can get all kinds of feedbacks and the count of every kinds of feedbacks.
-- 2. calculate the sum of 
--      (count of each feedback) * (count of each feedback/ all feedback count)
calculateExpectation :: [Pitch] -> [[Pitch]] -> Int
calculateExpectation pitchSet pitchCandidates = foldl calculateUnit 0 feedbackNumbers
    where
        getFeedback pitchCandidate = feedback pitchSet pitchCandidate 
        calculateUnit expection num = expection + (num * num) 
        feedbacks = sort (map getFeedback pitchCandidates)
        feedbacksAfterGroup = group (feedbacks)
        feedbackNumbers = map length feedbacksAfterGroup